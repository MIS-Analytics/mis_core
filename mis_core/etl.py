# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_etl.ipynb.

# %% auto 0
__all__ = ['get_demo_data', 'format_timedelta', 'print_step_name', 'print_time', 'fill_between_df_parts',
           'print_sample_from_meta_dict', 'display_sample_from_df', 'space_strings', 'print_shape_change',
           'print_step_info', 'pipeline', 'track']

# %% ../nbs/10_etl.ipynb 5
import pandas as pd

# %% ../nbs/10_etl.ipynb 7
def get_demo_data():
    data = {
    'order_id': [101, 102, 103, 104, 105],
    'product': ['Widget A', 'Widget B', 'Widget A', 'Widget C', 'Widget B'],
    'quantity': [50, 30, 75, 20, 45],
    'defects': [2, 1, 3, 0, 2],
    'production_time': [120, 95, 150, 80, 110]  # in minutes
    }
    return pd.DataFrame(data)

# %% ../nbs/10_etl.ipynb 22
from datetime import datetime
from time import sleep

# %% ../nbs/10_etl.ipynb 36
from datetime import timedelta

# %% ../nbs/10_etl.ipynb 42
def format_timedelta(td):
    total_seconds = td.total_seconds()
    if total_seconds < 0.001: return f"{total_seconds * 1_000_000:.0f} µs"
    elif total_seconds < 1: return f"{total_seconds * 1000:.2f} ms"
    elif total_seconds < 60: return f"{total_seconds:.2f} s"
    elif total_seconds < 3600: return f"{total_seconds / 60:.2f} min"
    else: return f"{total_seconds / 3600:.2f} h"

# %% ../nbs/10_etl.ipynb 44
def print_step_name(meta_dict): print(15*'*' + ' ' + meta_dict['step_name'] + ' ' + 15*'*')

# %% ../nbs/10_etl.ipynb 46
def print_time(meta_dict):
    print(f'Total Time: {format_timedelta(meta_dict["total_time"])}')
    print('')
    print(f'Start: {meta_dict["in_time"]}')
    print(f'  End: {meta_dict["out_time"]}')

# %% ../nbs/10_etl.ipynb 50
import numpy as np

# %% ../nbs/10_etl.ipynb 55
def fill_between_df_parts(df):
    return pd.DataFrame(np.nan, index=[''], columns=df.columns).fillna(':')

# %% ../nbs/10_etl.ipynb 59
def print_sample_from_meta_dict(meta_dict, mode='in'):
    print(pd.concat([
        meta_dict[f'{mode}_df_head'], 
        fill_between_df_parts(meta_dict[f'{mode}_df_head']),
        meta_dict[f'{mode}_df_sample'], 
        fill_between_df_parts(meta_dict[f'{mode}_df_head']),
        meta_dict[f'{mode}_df_tail']
        ]))

# %% ../nbs/10_etl.ipynb 61
def display_sample_from_df(df):
    return pd.concat([
            df.head(3), 
            fill_between_df_parts(df),
            df.sample(min(5, df.shape[0])), 
            fill_between_df_parts(df),
            df.tail(3)]
    )

# %% ../nbs/10_etl.ipynb 71
def space_strings(strings, total_width):
    gap = (total_width - sum(len(s) for s in strings)) // (len(strings) - 1)
    return (' ' * gap).join(strings)

# %% ../nbs/10_etl.ipynb 81
def print_shape_change(meta_dict):
    in_rows, in_cols = meta_dict['in_df_shape']
    out_rows, out_cols = meta_dict['out_df_shape']
    diff_rows, diff_cols = out_rows - in_rows, out_cols - in_cols
    
    diff_rows_str = f"{diff_rows:+d}" if diff_rows != 0 else "0"
    diff_cols_str = f"{diff_cols:+d}" if diff_cols != 0 else "0"
    
    row_width = max(len(str(in_rows)), len(str(out_rows)), len(diff_rows_str))
    col_width = max(len(str(in_cols)), len(str(out_cols)), len(diff_cols_str))
    
    print(
        f"""
        Input:  {in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols
                {' '*row_width}   ↓   {' '*col_width}   ↓
        Diff:   {diff_rows_str:>{row_width}} rows, {diff_cols_str:>{col_width}} cols
                {' '*row_width}   ↓   {' '*col_width}   ↓
        Output: {out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols
        """)

# %% ../nbs/10_etl.ipynb 85
def print_step_info(meta_dict):
    print_step_name(meta_dict)
    print_time(meta_dict)
    print("\nInput DataFrame:")
    print_sample_from_meta_dict(meta_dict, mode='in')
    print_shape_change(meta_dict)
    print("Output DataFrame:")
    print_sample_from_meta_dict(meta_dict, mode='out')
    print('\n')

# %% ../nbs/10_etl.ipynb 89
def pipeline(df, steps, vrbs_default=True):
    for func, func_kwargs in steps:
        func_kwargs = func_kwargs.copy()
        vrbs =  func_kwargs.get("vrbs", vrbs_default)
        func_kwargs.update({"vrbs": vrbs})
        df = func(df, **func_kwargs)
    return df

# %% ../nbs/10_etl.ipynb 90
def track(func):
    def wrapper(in_df, vrbs=False, *args, **kwargs):
        meta_dict = {
            'step_name':func.__name__, # name of the pipeline step
            'in_time':datetime.now(), # time when the pipeline step starts
            'in_df_shape':in_df.shape, # shape of the input dataframe
            'in_df_head':in_df.head(3), # head of the input dataframe
            'in_df_sample':in_df.sample(min(in_df.shape[0], 5)), # sample of the input dataframe
            'in_df_tail':in_df.tail(3), # tail of the input dataframe
        }

        out_df = func(in_df, *args, **kwargs)

        out_time = datetime.now()
        total_time = out_time - meta_dict['in_time']
            
        meta_dict.update({
            'out_time':datetime.now(), # time when the pipeline step stops
            'out_df_shape':out_df.shape, # shape of the output dataframe
            'out_df_head':out_df.head(3), # head of the output dataframe
            'out_df_sample':out_df.sample(min(out_df.shape[0], 5)), # sample of the output dataframe
            'out_df_tail':out_df.tail(3), # tail of the output dataframe
            'total_time':total_time, # difference between in_time and out_time
        })

        if vrbs: print_step_info(meta_dict)
        
        return out_df
    return wrapper
