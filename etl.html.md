# Our plan


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

Tools available from `fastcore.tools`:

- &`rg`: Run the `rg` command with the args in `argstr` (no need to
  backslash escape)
- &`sed`: Run the `sed` command with the args in `argstr` (e.g for
  reading a section of a file)
- &`view`: View directory or file contents with optional line range and
  numbers
- &`create`: Creates a new file with the given content at the specified
  path
- &`insert`: Insert new_str at specified line number
- &`str_replace`: Replace first occurrence of old_str with new_str in
  file
- &`strs_replace`: Replace for each str pair in old_strs,new_strs
- &`replace_lines`: Replace lines in file using start and end
  line-numbers

``` python
# Sample manufacturing data
data = {
    'order_id': [101, 102, 103, 104, 105],
    'product': ['Widget A', 'Widget B', 'Widget A', 'Widget C', 'Widget B'],
    'quantity': [50, 30, 75, 20, 45],
    'defects': [2, 1, 3, 0, 2],
    'production_time': [120, 95, 150, 80, 110]  # in minutes
}

df = pd.DataFrame(data)
df
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
</tbody>
</table>

</div>

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L12"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_demo_data

>  get_demo_data ()

``` python
df[df["product"] != "Widget C"].groupby(["product"])[["quantity", "defects" ,"production_time"]].sum()
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
<tr>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">Widget A</td>
<td>125</td>
<td>5</td>
<td>270</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Widget B</td>
<td>75</td>
<td>3</td>
<td>205</td>
</tr>
</tbody>
</table>

</div>

# Solution space exploration

Show a simple example for each please

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

\#| hide

Iâ€™ll show you a simple example skeleton for each approach. Since you
asked explicitly, Iâ€™ll write out the code examples:

**1. Pipeline class approach:**

``` python
class ETLPipeline:
    def __init__(self, df):
        self.steps = []
        self.df = df
        
    def add_step(self, func, name):
        self.df = func(self.df)
        self.steps.append({'name': name, 'shape': self.df.shape})
        return self
    
    def get_result(self):
        return self.df
```

**2. Decorator approach:**

``` python
def track_step(step_name):
    def decorator(func):
        def wrapper(df):
            result = func(df)
            print(f"{step_name}: {result.shape}")
            return result
        return wrapper
    return decorator

@track_step("Filter")
def filter_products(df):
    return df[df["product"] != "Widget C"]
```

**3. Function list with runner:**

``` python
def run_pipeline(df, steps):
    results = []
    for name, func in steps:
        df = func(df)
        results.append({'step': name, 'shape': df.shape})
    return df, results
```

Which of these feels most natural for your workflow? Would you like to
try implementing one with your actual pipeline example?

How would we deal with methods vs functions in each approach?

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Good question! Methods vs functions is an important consideration for
each approach.

**Pipeline class**: Works naturally with both - you can pass either
functions or methods as long as they take a dataframe and return a
dataframe. Methods would need to be bound or wrapped.

**Decorator**: Best suited for functions. For methods, youâ€™d need to
handle `self` carefully in the wrapper, which adds complexity.

**Function list runner**: Similar to the pipeline class - works with
both as long as theyâ€™re callable and follow the df-in, df-out pattern.

The key question is: are you planning to use pandas methods (like
`.groupby()`, `.merge()`) or write your own functions that wrap those
operations? This might influence which approach fits best.

Whatâ€™s your typical style - do you prefer chaining pandas methods or
writing custom transform functions?

Can you write our small example transformation for each approach

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Since youâ€™ve explicitly asked me to write the code, Iâ€™ll create the full
example for each approach using your filter + groupby transformation:

**1. Pipeline class approach:**

``` python
class ETLPipeline:
    def __init__(self, df):
        self.steps = []
        self.df = df
        self.history = [{'step': 'initial', 'shape': df.shape, 'columns': list(df.columns)}]
        
    def add_step(self, func, name):
        self.df = func(self.df)
        self.history.append({'step': name, 'shape': self.df.shape, 'columns': list(self.df.columns)})
        return self
    
    def get_result(self):
        return self.df
    
    def show_history(self):
        return pd.DataFrame(self.history)

# Usage
pipeline = ETLPipeline(df)
result = (pipeline
    .add_step(lambda d: d[d["product"] != "Widget C"], "filter_widget_c")
    .add_step(lambda d: d.groupby(["product"])[["quantity", "defects", "production_time"]].sum(), "aggregate")
    .get_result())

print(pipeline.show_history())
print("\nResult:")
print(result)
```

**2. Decorator approach:**

``` python
steps_log = []

def track_step(step_name):
    def decorator(func):
        def wrapper(df):
            result = func(df)
            steps_log.append({'step': step_name, 'shape': result.shape, 'columns': list(result.columns)})
            return result
        return wrapper
    return decorator

@track_step("filter_widget_c")
def filter_products(df):
    return df[df["product"] != "Widget C"]

@track_step("aggregate")
def aggregate_by_product(df):
    return df.groupby(["product"])[["quantity", "defects", "production_time"]].sum()

# Usage
result = aggregate_by_product(filter_products(df))
print(pd.DataFrame(steps_log))
print("\nResult:")
print(result)
```

**3. Function list with runner:**

``` python
def run_pipeline(df, steps):
    history = [{'step': 'initial', 'shape': df.shape, 'columns': list(df.columns)}]
    current_df = df
    
    for name, func in steps:
        current_df = func(current_df)
        history.append({'step': name, 'shape': current_df.shape, 'columns': list(current_df.columns)})
    
    return current_df, pd.DataFrame(history)

# Define steps
steps = [
    ("filter_widget_c", lambda d: d[d["product"] != "Widget C"]),
    ("aggregate", lambda d: d.groupby(["product"])[["quantity", "defects", "production_time"]].sum())
]

# Usage
result, history = run_pipeline(df, steps)
print(history)
print("\nResult:")
print(result)
```

Try running these! Which approach feels most intuitive for your
workflow?

# Our preferred approach

So we are thinking of a hybrid of 2 and 3). So we would write a
decorator that adds a logging keyword to each function, then we can
determine for each function in the pipeline what to log/how much to log.
We want to keep it as simple as possible. The pipeline should just take
a df and a list of functions as steps of the pipeline.

``` python
def pipeline(df, steps, vrbs_default=True):
    for func, func_kwargs in steps:
        vrbs =  func_kwargs.get("vrbs", vrbs_default)
        func_kwargs.update({"vrbs": vrbs})
        df = func(df, **func_kwargs)
    return df
```

``` python
def track(func):
    def wrapper(in_df, vrbs=False, *args, **kwargs):
        if vrbs:
            print(f"\n{'*'*10} Step: {func.__name__} {'*'*10}")
            print(f"\nInput DataFrame shape: {in_df.shape}")
            print(in_df)
        out_df = func(in_df, *args, **kwargs)
        if vrbs:
            print(f"\nOutput DataFrame shape: {out_df.shape}")
            print(out_df)
        return out_df
    return wrapper
```

``` python
@track
def filter_products(df):
    return df[df["product"] != "Widget C"]

@track
def aggregate_by_product(df):
    return df.groupby(["product"])[["quantity", "defects", "production_time"]].sum()
```

We include a way to handle pipeline overwrites of the `vrbs` argument
for specific transformation steps. In this example, no information for
`aggregate_by_product` is printed:

``` python
steps = [
    (filter_products, {}),
    (aggregate_by_product, {"vrbs": False}),
]
```

``` python
pipeline(df, steps)
```


    ********** Step: filter_products **********

    Input DataFrame shape: (5, 5)
       order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    3       104  Widget C        20        0               80
    4       105  Widget B        45        2              110

    Output DataFrame shape: (4, 5)
       order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
<tr>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">Widget A</td>
<td>125</td>
<td>5</td>
<td>270</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">Widget B</td>
<td>75</td>
<td>3</td>
<td>205</td>
</tr>
</tbody>
</table>

</div>

We want to add basic profiling of time and memory.

``` python
start_time = datetime.now()
sleep(3.14)
end_time = datetime.now()
total_time = end_time - start_time
total_time
```

    datetime.timedelta(seconds=3, microseconds=140295)

``` python
start_time
```

    datetime.datetime(2025, 12, 18, 16, 9, 29, 40016)

``` python
def track(func):
    def wrapper(in_df, vrbs=False, *args, **kwargs):
        start_time = datetime.now()
        if vrbs:
            
            print(f"\n{'*'*10} Step: {func.__name__} {'*'*10}")
            print(f"\nInput DataFrame shape: {in_df.shape}")
            print(f"Start time: {start_time}")
            print(in_df)
        out_df = func(in_df, *args, **kwargs)
        

        end_time = datetime.now()
        total_time = end_time - start_time
        if vrbs:
            print(f"\nOutput DataFrame shape: {out_df.shape}")
            print(f"End time: {end_time}")
            print(f"Total time: {total_time}")
            print(out_df)
        return out_df
    return wrapper
```

``` python
@track
def filter_products(df):
    return df[df["product"] != "Widget C"]

@track
def aggregate_by_product(df):
    return df.groupby(["product"])[["quantity", "defects", "production_time"]].sum()
```

``` python
steps = [
    (filter_products, {}),
    (aggregate_by_product, {}),
]
```

``` python
_df = pipeline(df, steps)
```


    ********** Step: filter_products **********

    Input DataFrame shape: (5, 5)
    Start time: 2025-12-18 16:09:32.350126
       order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    3       104  Widget C        20        0               80
    4       105  Widget B        45        2              110

    Output DataFrame shape: (4, 5)
    End time: 2025-12-18 16:09:32.352835
    Total time: 0:00:00.002709
       order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110

    ********** Step: aggregate_by_product **********

    Input DataFrame shape: (4, 5)
    Start time: 2025-12-18 16:09:32.354253
       order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110

    Output DataFrame shape: (2, 3)
    End time: 2025-12-18 16:09:32.357215
    Total time: 0:00:00.002962
              quantity  defects  production_time
    product                                     
    Widget A       125        5              270
    Widget B        75        3              205

# first reflection and next steps

- right now we are still printing the whole dataframe. We want to change
  that to just show the first 3, 5 random and the last 3 rows, maybe
  with some visual clue to show that the rows are truncated.

- we would also like show the dataframes to the right of the aggregate
  infos (like shape, etc.)

- include information like df.info()

- include information like df.describe()

- include information like diff columns (num cols changed, cols just in
  before, cols just in after)

- include information like diff rows (maybe just the number)

- source code of functions

- description of step, based on docstring

- nicer representation maybe in html or display or something like that

- new wrapper to include assertions and/or sanity checks (propertiy
  based, for example same number of mat_ids)

- function generate pipeline report, in excel (or something else)

Okay our first idea after picking the problem back up is to store the
information in a dictionary and then create different functions to
display the information.

``` python
def track(func):
    def wrapper(in_df, vrbs=False, *args, **kwargs):
        meta_dict = {
            'step_name':func.__name__, # name of the pipeline step
            'in_time':datetime.now(), # time when the pipeline step starts
            'in_df_shape':in_df.shape, # shape of the input dataframe
            'in_df_head':in_df.head(3), # head of the input dataframe
            'in_df_sample':in_df.sample(min(in_df.shape[0], 5)), # sample of the input dataframe
            'in_df_tail':in_df.tail(3), # tail of the input dataframe
        }

        out_df = func(in_df, *args, **kwargs)

        out_time = datetime.now()
        total_time = out_time - meta_dict['in_time']
            
        meta_dict.update({
            'out_time':datetime.now(), # time when the pipeline step stops
            'out_df_shape':out_df.shape, # shape of the output dataframe
            'out_df_head':out_df.head(3), # head of the output dataframe
            'out_df_sample':out_df.sample(min(out_df.shape[0], 5)), # sample of the output dataframe
            'out_df_tail':out_df.tail(3), # tail of the output dataframe
            'total_time':total_time, # difference between in_time and out_time
        })

        if vrbs:
            print('Here we use a fuction to display the information')
            print(meta_dict)
        
        return out_df
    return wrapper
```

``` python
@track
def filter_products(df):
    return df[df["product"] != "Widget C"]

@track
def aggregate_by_product(df):
    return df.groupby(["product"])[["quantity", "defects", "production_time"]].sum()
```

``` python
steps = [
    (filter_products, {}),
    (aggregate_by_product, {}),
]
```

``` python
_df = pipeline(df, steps)
```

    Here we use a fuction to display the information
    {'step_name': 'filter_products', 'in_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 552068), 'in_df_shape': (5, 5), 'in_df_head':    order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150, 'in_df_sample':    order_id   product  quantity  defects  production_time
    1       102  Widget B        30        1               95
    4       105  Widget B        45        2              110
    0       101  Widget A        50        2              120
    3       104  Widget C        20        0               80
    2       103  Widget A        75        3              150, 'in_df_tail':    order_id   product  quantity  defects  production_time
    2       103  Widget A        75        3              150
    3       104  Widget C        20        0               80
    4       105  Widget B        45        2              110, 'out_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 553303), 'out_df_shape': (4, 5), 'out_df_head':    order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150, 'out_df_sample':    order_id   product  quantity  defects  production_time
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110
    0       101  Widget A        50        2              120, 'out_df_tail':    order_id   product  quantity  defects  production_time
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110, 'total_time': datetime.timedelta(microseconds=1230)}
    Here we use a fuction to display the information
    {'step_name': 'aggregate_by_product', 'in_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 561168), 'in_df_shape': (4, 5), 'in_df_head':    order_id   product  quantity  defects  production_time
    0       101  Widget A        50        2              120
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150, 'in_df_sample':    order_id   product  quantity  defects  production_time
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    0       101  Widget A        50        2              120
    4       105  Widget B        45        2              110, 'in_df_tail':    order_id   product  quantity  defects  production_time
    1       102  Widget B        30        1               95
    2       103  Widget A        75        3              150
    4       105  Widget B        45        2              110, 'out_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 563028), 'out_df_shape': (2, 3), 'out_df_head':           quantity  defects  production_time
    product                                     
    Widget A       125        5              270
    Widget B        75        3              205, 'out_df_sample':           quantity  defects  production_time
    product                                     
    Widget A       125        5              270
    Widget B        75        3              205, 'out_df_tail':           quantity  defects  production_time
    product                                     
    Widget A       125        5              270
    Widget B        75        3              205, 'total_time': datetime.timedelta(microseconds=1853)}

# display functions

Here we created a sample meta_dict to play around and create different
functions to display the information

``` python
meta_dict = {
    'step_name': 'filter_products',
    'in_time': datetime.now(),
    'in_df_shape': (5, 5),
    'in_df_head': df.head(3),
    'in_df_sample': df.sample(min(df.shape[0], 5)),
    'in_df_tail': df.tail(3),
    'out_time': datetime.now(),
    'out_df_shape': (4, 5),
    'out_df_head': df[df["product"] != "Widget C"].head(3),
    'out_df_sample': df[df["product"] != "Widget C"].sample(min(4, 5)),
    'out_df_tail': df[df["product"] != "Widget C"].tail(3),
    'total_time': timedelta(microseconds=1287)
}

meta_dict
```

    {'step_name': 'filter_products',
     'in_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 626829),
     'in_df_shape': (5, 5),
     'in_df_head':    order_id   product  quantity  defects  production_time
     0       101  Widget A        50        2              120
     1       102  Widget B        30        1               95
     2       103  Widget A        75        3              150,
     'in_df_sample':    order_id   product  quantity  defects  production_time
     2       103  Widget A        75        3              150
     4       105  Widget B        45        2              110
     1       102  Widget B        30        1               95
     0       101  Widget A        50        2              120
     3       104  Widget C        20        0               80,
     'in_df_tail':    order_id   product  quantity  defects  production_time
     2       103  Widget A        75        3              150
     3       104  Widget C        20        0               80
     4       105  Widget B        45        2              110,
     'out_time': datetime.datetime(2025, 12, 18, 16, 9, 32, 627481),
     'out_df_shape': (4, 5),
     'out_df_head':    order_id   product  quantity  defects  production_time
     0       101  Widget A        50        2              120
     1       102  Widget B        30        1               95
     2       103  Widget A        75        3              150,
     'out_df_sample':    order_id   product  quantity  defects  production_time
     2       103  Widget A        75        3              150
     0       101  Widget A        50        2              120
     1       102  Widget B        30        1               95
     4       105  Widget B        45        2              110,
     'out_df_tail':    order_id   product  quantity  defects  production_time
     1       102  Widget B        30        1               95
     2       103  Widget A        75        3              150
     4       105  Widget B        45        2              110,
     'total_time': datetime.timedelta(microseconds=1287)}

## print name and time

``` python
print(15*'*' + ' ' + meta_dict['step_name'] + ' ' + 15*'*')
```

    *************** filter_products ***************

``` python
print(f'Total Time: {meta_dict["total_time"]}')
print(f'Start: {meta_dict["in_time"]}')
print(f'End: {meta_dict["out_time"]}')
```

    Total Time: 0:00:00.001287
    Start: 2025-12-18 16:09:32.626829
    End: 2025-12-18 16:09:32.627481

is there a convenient way to print the time_delta in different formats
according to the time elapsed (eg ms, s, min, etc)?

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Good question! There isnâ€™t a built-in method for `timedelta` to
auto-format based on magnitude, but you can write a simple helper
function. Hereâ€™s a compact approach:

``` python
def format_timedelta(td):
    total_seconds = td.total_seconds()
    if total_seconds < 0.001:
        return f"{total_seconds * 1_000_000:.0f} Âµs"
    elif total_seconds < 1:
        return f"{total_seconds * 1000:.2f} ms"
    elif total_seconds < 60:
        return f"{total_seconds:.2f} s"
    elif total_seconds < 3600:
        return f"{total_seconds / 60:.2f} min"
    else:
        return f"{total_seconds / 3600:.2f} h"
```

You could then use it like:

``` python
print(f'Total Time: {format_timedelta(meta_dict["total_time"])}')
```

Would you like to try this out with your meta_dict?

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L30"
target="_blank" style="float:right; font-size:smaller">source</a>

### format_timedelta

>  format_timedelta (td)

``` python
print(f'Total Time: {format_timedelta(meta_dict["total_time"])}')
```

    Total Time: 1.29 ms

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L39"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_step_name

>  print_step_name (meta_dict)

``` python
print_step_name(meta_dict)
```

    *************** filter_products ***************

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L42"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_time

>  print_time (meta_dict)

``` python
print_time(meta_dict)
```

    Total Time: 1.29 ms

    Start: 2025-12-18 16:09:32.626829
      End: 2025-12-18 16:09:32.627481

## print sample df

``` python
pd.concat([meta_dict['in_df_head'], meta_dict['in_df_sample'], meta_dict['in_df_tail']])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
</tbody>
</table>

</div>

``` python
pd.DataFrame(np.nan, index=range(1), columns=meta_dict['in_df_head'].columns)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

</div>

``` python
pd.DataFrame(np.nan, index=range(1), columns=meta_dict['in_df_head'].columns).fillna('...')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>

</div>

``` python
pd.DataFrame(np.nan, index=range(3), columns=meta_dict['in_df_head'].columns).fillna('.')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
</tbody>
</table>

</div>

``` python
pd.DataFrame(np.nan, index=range(1), columns=meta_dict['in_df_head'].columns).fillna(':')
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
</tbody>
</table>

</div>

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L52"
target="_blank" style="float:right; font-size:smaller">source</a>

### fill_between_df_parts

>  fill_between_df_parts (df)

``` python
fill_between_df_parts(meta_dict['in_df_head'])
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th"></td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
</tbody>
</table>

</div>

``` python
pd.concat(
    [meta_dict['in_df_head'], 
    fill_between_df_parts(meta_dict['in_df_head']),
    meta_dict['in_df_sample'], 
    fill_between_df_parts(meta_dict['in_df_head']),
    meta_dict['in_df_tail']]
    )
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th"></td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th"></td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
</tbody>
</table>

</div>

We want to build to functions: 1. a display function for within our
wrapper which only uses the meta_dict 2. a display function that just
takes in one df and gets the head, sample, tail from there

In the future we might want to turn this into one function but for now
we donâ€™t want to store the whole df in meta_dict

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L56"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_sample_from_meta_dict

>  print_sample_from_meta_dict (meta_dict, mode='in')

``` python
print_sample_from_meta_dict(meta_dict)
```

      order_id   product quantity defects production_time
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
             :         :        :       :               :
    2      103  Widget A       75       3             150
    4      105  Widget B       45       2             110
    1      102  Widget B       30       1              95
    0      101  Widget A       50       2             120
    3      104  Widget C       20       0              80
             :         :        :       :               :
    2      103  Widget A       75       3             150
    3      104  Widget C       20       0              80
    4      105  Widget B       45       2             110

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L66"
target="_blank" style="float:right; font-size:smaller">source</a>

### display_sample_from_df

>  display_sample_from_df (df)

``` python
display_sample_from_df(df)
```

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&#10;    .dataframe tbody tr th {
        vertical-align: top;
    }
&#10;    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe" data-quarto-postprocess="true" data-border="1">
<thead>
<tr style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">order_id</th>
<th data-quarto-table-cell-role="th">product</th>
<th data-quarto-table-cell-role="th">quantity</th>
<th data-quarto-table-cell-role="th">defects</th>
<th data-quarto-table-cell-role="th">production_time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th"></td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">1</td>
<td>102</td>
<td>Widget B</td>
<td>30</td>
<td>1</td>
<td>95</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">0</td>
<td>101</td>
<td>Widget A</td>
<td>50</td>
<td>2</td>
<td>120</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th"></td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
<td>:</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">2</td>
<td>103</td>
<td>Widget A</td>
<td>75</td>
<td>3</td>
<td>150</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">3</td>
<td>104</td>
<td>Widget C</td>
<td>20</td>
<td>0</td>
<td>80</td>
</tr>
<tr>
<td data-quarto-table-cell-role="th">4</td>
<td>105</td>
<td>Widget B</td>
<td>45</td>
<td>2</td>
<td>110</td>
</tr>
</tbody>
</table>

</div>

We will have to also consider what happen if we have to many columns.

Our idea is to truncate them as well and just add a dummy columns with
â€˜â€¦â€™ as sign that its truncated

## print shape and shape change

``` python
print('(rows, columns) =', meta_dict['in_df_shape'])
print('        |          ')
print('        V          ')
print('(rows, columns) =', meta_dict['out_df_shape'])
```

    (rows, columns) = (5, 5)
            |          
            V          
    (rows, columns) = (4, 5)

``` python
print('(rows, columns) =', meta_dict['in_df_shape'])
print(' â†“ '*8)
print('(rows, columns) =', meta_dict['out_df_shape'])
```

    (rows, columns) = (5, 5)
     â†“  â†“  â†“  â†“  â†“  â†“  â†“  â†“ 
    (rows, columns) = (4, 5)

``` python
in_str = f"{meta_dict['in_df_shape'][0]} rows, {meta_dict['in_df_shape'][1]} columns"
print(in_str)
print('â†“ â†“ â†“'.center(len(in_str), ' '))
print(f"{meta_dict['out_df_shape'][0]} rows, {meta_dict['out_df_shape'][1]} columns")
```

    5 rows, 5 columns
          â†“ â†“ â†“      
    4 rows, 5 columns

is there a convenietn way to space out a number of strings over a
specific length?

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

You could use string formatting with padding! Here are a couple of
approaches:

**1. Using f-strings with alignment:**

``` python
s1, s2, s3 = "5 rows", "4 columns", "time: 1.2ms"
total_width = 50
print(f"{s1:<{total_width//3}}{s2:<{total_width//3}}{s3}")
```

**2. Using `str.ljust()` / `str.center()` / `str.rjust()`:**

``` python
width = 20
print(s1.ljust(width) + s2.center(width) + s3.rjust(width))
```

**3. For evenly spacing multiple strings, you could calculate spacing:**

``` python
def space_strings(strings, total_width):
    gap = (total_width - sum(len(s) for s in strings)) // (len(strings) - 1)
    return (' ' * gap).join(strings)
```

Which approach fits what youâ€™re trying to do with your pipeline display?

``` python
s1, s2, s3 = "5 rows", "4 columns", "time: 1.2ms"
total_width = 50
print(f"{s1:<{total_width//3}}{s2:<{total_width//3}}{s3}")
```

    5 rows          4 columns       time: 1.2ms

``` python
width = 20
print(s1.ljust(width) + s2.center(width) + s3.rjust(width))
```

    5 rows                   4 columns               time: 1.2ms

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L76"
target="_blank" style="float:right; font-size:smaller">source</a>

### space_strings

>  space_strings (strings, total_width)

``` python
space_strings(['|', '|', '|'], 20)
```

    '|        |        |'

``` python
len(space_strings(['|', '|', '|'], 20))
```

    19

``` python
in_str = f"{meta_dict['in_df_shape'][0]} rows, {meta_dict['in_df_shape'][1]} columns"
print(in_str)
print(space_strings(['â†“','â†“','â†“'], len(in_str)))
print(f"{meta_dict['out_df_shape'][0]} rows, {meta_dict['out_df_shape'][1]} columns")
```

    5 rows, 5 columns
    â†“       â†“       â†“
    4 rows, 5 columns

``` python
in_rows, in_cols = meta_dict['in_df_shape']
out_rows, out_cols = meta_dict['out_df_shape']

in_str = f"{in_rows} rows, {in_cols} columns"
print(in_str)
print(space_strings(['â†“','â†“','â†“'], len(in_str)))

print(f'{str(out_rows-in_rows).center(len(in_str)//2)}', f'{str(out_cols-in_cols).center(len(in_str)//2)}')

print(space_strings(['â†“','â†“','â†“'], len(in_str)))
print(f"{out_rows} rows, {out_cols} columns")
```

    5 rows, 5 columns
    â†“       â†“       â†“
       -1       0    
    â†“       â†“       â†“
    4 rows, 5 columns

write code to print the in shape and out shape and the diff in rows and
cols in between in a way that the numbers a right aligned (rows to rows
and cols to cols)

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ ðŸ§ 

``` python
in_rows, in_cols = meta_dict['in_df_shape']
out_rows, out_cols = meta_dict['out_df_shape']
diff_rows, diff_cols = out_rows - in_rows, out_cols - in_cols

# Format with sign for diff
diff_rows_str = f"{diff_rows:+d}" if diff_rows != 0 else "0"
diff_cols_str = f"{diff_cols:+d}" if diff_cols != 0 else "0"

# Right-align each column
row_width = max(len(str(in_rows)), len(str(out_rows)), len(diff_rows_str))
col_width = max(len(str(in_cols)), len(str(out_cols)), len(diff_cols_str))

print(f"{in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols")
print(f"{' '*row_width}   â†“   {' '*col_width}   â†“")
print(f"{diff_rows_str:>{row_width}}      {diff_cols_str:>{col_width}}")
print(f"{' '*row_width}   â†“   {' '*col_width}   â†“")
print(f"{out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols")
```

``` python
in_rows, in_cols = meta_dict['in_df_shape']
out_rows, out_cols = meta_dict['out_df_shape']
diff_rows, diff_cols = out_rows - in_rows, out_cols - in_cols

diff_rows_str = f"{diff_rows:+d}" if diff_rows != 0 else "0"
diff_cols_str = f"{diff_cols:+d}" if diff_cols != 0 else "0"

# Right-align each column
row_width = max(len(str(in_rows)), len(str(out_rows)), len(diff_rows_str))
col_width = max(len(str(in_cols)), len(str(out_cols)), len(diff_cols_str))

print(f"Input:  {in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols")
print(f"        {' '*row_width}   â†“   {' '*col_width}   â†“")
print(f"Diff:   {diff_rows_str:>{row_width}} rows, {diff_cols_str:>{col_width}} cols")
print(f"        {' '*row_width}   â†“   {' '*col_width}   â†“")
print(f"Output: {out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols")
```

    Input:   5 rows, 5 cols
                 â†“       â†“
    Diff:   -1 rows, 0 cols
                 â†“       â†“
    Output:  4 rows, 5 cols

write this into a big f_string

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Hereâ€™s how to combine it into one f-string:

``` python
print(f"""Input:  {in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Diff:   {diff_rows_str:>{row_width}} rows, {diff_cols_str:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Output: {out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols""")
```

The triple quotes `"""` let you write multi-line strings with all the
formatting preserved.

``` python
print(f"""
Input:  {in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Diff:   {diff_rows_str:>{row_width}} rows, {diff_cols_str:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Output: {out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols
""")
```


    Input:   5 rows, 5 cols
                 â†“       â†“
    Diff:   -1 rows, 0 cols
                 â†“       â†“
    Output:  4 rows, 5 cols

write a function to display this which takes the meta_dict as input

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

``` python
def display_shape_change(meta_dict):
    in_rows, in_cols = meta_dict['in_df_shape']
    out_rows, out_cols = meta_dict['out_df_shape']
    diff_rows, diff_cols = out_rows - in_rows, out_cols - in_cols
    
    diff_rows_str = f"{diff_rows:+d}" if diff_rows != 0 else "0"
    diff_cols_str = f"{diff_cols:+d}" if diff_cols != 0 else "0"
    
    row_width = max(len(str(in_rows)), len(str(out_rows)), len(diff_rows_str))
    col_width = max(len(str(in_cols)), len(str(out_cols)), len(diff_cols_str))
    
    print(f"""
Input:  {in_rows:>{row_width}} rows, {in_cols:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Diff:   {diff_rows_str:>{row_width}} rows, {diff_cols_str:>{col_width}} cols
        {' '*row_width}   â†“   {' '*col_width}   â†“
Output: {out_rows:>{row_width}} rows, {out_cols:>{col_width}} cols
""")
```

Try calling it with `display_shape_change(meta_dict)` to test it out!

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L81"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_shape_change

>  print_shape_change (meta_dict)

``` python
print_shape_change(meta_dict)
```


            Input:   5 rows, 5 cols
                         â†“       â†“
            Diff:   -1 rows, 0 cols
                         â†“       â†“
            Output:  4 rows, 5 cols
            

## print all function

make one big print_step_infos function with our defined functions

##### ðŸ¤–ReplyðŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Hereâ€™s a combined function that uses all the display functions youâ€™ve
created:

``` python
def print_step_info(meta_dict):
    print_step_name(meta_dict)
    print_time(meta_dict)
    print_shape_change(meta_dict)
    print("\nInput DataFrame:")
    print_sample_from_meta_dict(meta_dict, mode='in')
    print("\nOutput DataFrame:")
    print_sample_from_meta_dict(meta_dict, mode='out')
```

This brings together all your display functions into one. Would you like
to test it with your `meta_dict`, or would you prefer to adjust what
information gets displayed or the order?

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L102"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_step_info

>  print_step_info (meta_dict)

``` python
print_step_info(meta_dict)
```

    *************** filter_products ***************
    Total Time: 1.29 ms

    Start: 2025-12-18 16:09:32.626829
      End: 2025-12-18 16:09:32.627481

    Input DataFrame:
      order_id   product quantity defects production_time
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
             :         :        :       :               :
    2      103  Widget A       75       3             150
    4      105  Widget B       45       2             110
    1      102  Widget B       30       1              95
    0      101  Widget A       50       2             120
    3      104  Widget C       20       0              80
             :         :        :       :               :
    2      103  Widget A       75       3             150
    3      104  Widget C       20       0              80
    4      105  Widget B       45       2             110

            Input:   5 rows, 5 cols
                         â†“       â†“
            Diff:   -1 rows, 0 cols
                         â†“       â†“
            Output:  4 rows, 5 cols
            
    Output DataFrame:
      order_id   product quantity defects production_time
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
             :         :        :       :               :
    2      103  Widget A       75       3             150
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    4      105  Widget B       45       2             110
             :         :        :       :               :
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
    4      105  Widget B       45       2             110

# Testing the pipeline

The issue is that `func_kwargs.update()` **mutates the original
dictionary** in your `steps` list. So if you ran the pipeline earlier
with `vrbs_default=True`, the empty `{}` for `aggregate_by_product` got
modified to `{'vrbs': True}` â€” and that change persists!

Try adding `.copy()` before updating:

``` python
func_kwargs = func_kwargs.copy()
```

That way youâ€™re modifying a copy, not the original dictionary in
`steps`.

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L113"
target="_blank" style="float:right; font-size:smaller">source</a>

### pipeline

>  pipeline (df, steps, vrbs_default=True)

------------------------------------------------------------------------

<a
href="https://github.com/MIS-Analytics/mis_core/blob/main/mis_core/etl.py#L122"
target="_blank" style="float:right; font-size:smaller">source</a>

### track

>  track (func)

``` python
@track
def filter_products(df):
    return df[df["product"] != "Widget C"]
```

``` python
@track
def aggregate_by_product(df):
    return df.groupby(["product"])[["quantity", "defects", "production_time"]].sum()
```

``` python
steps = [
    (filter_products, {'vrbs':True}),
    (aggregate_by_product, {}),
]
```

``` python
_df = pipeline(df, steps, vrbs_default=False)
```

    *************** filter_products ***************
    Total Time: 1.20 ms

    Start: 2025-12-18 16:09:33.725387
      End: 2025-12-18 16:09:33.726593

    Input DataFrame:
      order_id   product quantity defects production_time
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
             :         :        :       :               :
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
    0      101  Widget A       50       2             120
    4      105  Widget B       45       2             110
    3      104  Widget C       20       0              80
             :         :        :       :               :
    2      103  Widget A       75       3             150
    3      104  Widget C       20       0              80
    4      105  Widget B       45       2             110

            Input:   5 rows, 5 cols
                         â†“       â†“
            Diff:   -1 rows, 0 cols
                         â†“       â†“
            Output:  4 rows, 5 cols
            
    Output DataFrame:
      order_id   product quantity defects production_time
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
             :         :        :       :               :
    2      103  Widget A       75       3             150
    0      101  Widget A       50       2             120
    1      102  Widget B       30       1              95
    4      105  Widget B       45       2             110
             :         :        :       :               :
    1      102  Widget B       30       1              95
    2      103  Widget A       75       3             150
    4      105  Widget B       45       2             110
